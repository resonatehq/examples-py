Restate









ðŸŽ‰Â Â Announcing Restate 1.0, RestateÂ Cloud, and our Seed Funding Round Â Â Read moreGet StartedQuickstartTour of RestateCompanyAboutCareersDocsBlogCloudGet RestateThe simplest way to build resilient applications.As regular functions and services, in your existing infrastructure. On FaaS, K8s, servers, containers. Self-hosted or fully managed. Restate meets you where you are.> Quickstart> Open Source Restate> See how it works> Restate CloudWorkflows as codeAsync Tasks, Timers, SchedulersEvent-driven ApplicationsMicroService OrchestrationEasy solutions for common challengesWorkflows as codeAPI calls and webhooksAsynchronous TasksStateful Event ProcessingDurable SignalsIdempotencySagasState machinesWorkflows as codeDurable Execution ensures code runs reliably to the end, even in the presence of failures.â€Failures and errors are automatically retried (unless labeled as terminal errors)Functions can memoize the results of code blocks, and actions like RPC, in a journal. Completed steps are not re-executed during retries, but replayed from the journal.Workflows are built with regular code and control flow, no custom DSLs needed.Durable sleeps let code wait and suspend for up to monthsâ€> Learn MoreJSJSJavaKotlinPythonRustGoJSJavaKotlinPythonRustGo
export default restate.service({
  name: "roleUpdate",
  handlers: {
    applyRoleUpdate: async (ctx, update) => {
      const { userId, role, permissions } = update;
      const applied = await ctx.run("apply new role", () =>
        applyUserRole(userId, role)
      );
      if (!applied) {
        return;
      }
      for (const permission of permissions) {
        await ctx.run("apply permission", () =>
          applyPermission(userId, permission)
        );
      }
    }
  }
});


@Service
public class RoleUpdateService {

    @Handler
    public void applyRoleUpdate(Context ctx, Update update) {

        boolean success = ctx.run("apply new role", BOOLEAN,
            () -> applyUserRole(update.getUserId(), update.getRole()));

        if (!success) {
            return;
        }

        for (String permission : update.getPermissions()) {
            ctx.run("apply permission",
                () -> applyPermission(update.getUserId(), permission));
        }
    }
}

API calls and webhooksReliably join synchronous code and async events like webhooksWebhooks/events are persisted in Restateâ€™s log and reliably delivered to servicesPersistent Promises/Futures easily join synchronous and asynchronous code pathsDurable execution ensures reliable completion, whether webhooks come after milliseconds or months, and avoid re-execution of completed steps.> Learn MoreJSJSJavaKotlinPythonRustGoJSJavaKotlinPythonRustGo
const paymentSvc = restate.service({
  name: "payments",
  handlers: {
    processPayment: async (ctx, request) => {
      const webhookPromise = ctx.awakeable();
      const paymentIntent = await ctx.run("stripe call", () =>
        createPaymentIntent({
          request,
          metadata: { restate_callback_id: webhookPromise.id }
        })
      );
      if (paymentIntent.status === "processing") {
        // synchronous response inconclusive, await webhook response
        const paymentIntentFromWebhook = await webhookPromise.promise;
        return verifyPayment(paymentIntentFromWebhook);
      } else {
        return verifyPayment(paymentIntent);
      }
    },
    processWebhook: async (ctx) => {
      const paymentIntent = verifyAndParseEvent(ctx.request());
      const webhookPromiseId = paymentIntent.metadata.restate_callback_id;
      ctx.resolveAwakeable(webhookPromiseId, paymentIntent);
    }
  }
});


@Service
public class PaymentService {
  @Handler
  public void processPayment(Context ctx, PaymentRequest request) {
    var webhookFuture = ctx.awakeable(SERDE);
    var payment = ctx.run("Stripe call", SERDE, () -> submitPayment(
            request, Map.of("restate_callback_id", webhookFuture.id())
    ));
    if (payment.getStatus().equals("processing")) {
      // synchronous response inconclusive, await webhook response
      var updatedPayment = webhookFuture.await();
      verifyPayment(updatedPayment);
    } else {
      verifyPayment(payment);
    }
  }
  @Handler
  public void processWebhook(Context ctx) {
    var paymentEvent = verifyAndParseEvent(ctx.request());
    String callbackId = paymentEvent.getMetadata().get("restate_callback_id");
    ctx.awakeableHandle(callbackId).resolve(SERDE, paymentEvent);
  }
}

Asynchronous TasksAll functions invoked through Restate are executed durably and asynchronous.Deploy async functions serverless or as containers or processes.Call functions synchronously, async, or delayed. Re-attach and await from anywhere.Build async patterns like fan-out, fan-in, task chains, and subtasks simply with function calls and Futures/Promises.Use persistent timers to schedule tasks into the future.Use fine-grained virtual queues (via virtual objects) to enforce strict task order and concurrency> Learn MoreJSJSJavaKotlinPythonRustGoJSJavaKotlinPythonRustGo
// ------ service (= worker) ------
const asyncTaskService = restate.service({
    name: "taskWorker",
    handlers: { processPayment }
});
// ------ client ------
const rs = clients.connect({ url: process.env.RESTATE_URL });
const taskWorker = rs.serviceSendClient({ name: "taskWorker" });
// submit the payment task 
app.post('/charge/:paymentId', async (req, res) => {
    const taskHandle = await taskWorker.processPayment(
        { request: req.params },
        SendOpts.from({ idempotencyKey: req.params.paymentId })
    );
    res.json(taskHandle);
});
// await the payment task
app.get('/status', async (req,res) => {
        const taskHandle = req.body.json();
        const paymentResult = await restate.result(taskHandle); 
        res.join(paymentResult);
});


// --- start payment task ---
server.createContext("/charge", httpExchange -> {
  PaymentRequest req = parsePaymentRequest(httpExchange);
  SendResponse handle = AsyncTaskServiceClient
      .fromIngress(RESTATE_URI)
      .send()
      .processPayment(req, idempotencyKey(req.getPaymentId()));

  respondJson(httpExchange, handle);
});
//  --- connect to payment result ---
server.createContext("/status", httpExchange -> {
  String handle = parseToHandle(httpExchange);
  String response = IngressClient.defaultClient(RESTATE_URI)
      .invocationHandle(handle, STRING)
      .attach();
  respond(httpExchange, response);
});

Stateful Event ProcessingProcess events (for example from Kafka) with durable functions as event handlers and get fine-grained retries and workflow-as-code semantics.No queue subscriptions, no manual offset management, scaling, or balancingDeploy the event processing logic as serverless functions on FaaSKeep exactly-once state, delay events, run multiple asynchronous steps or API calls.Restateâ€™s queue-per-key semantics mean no more head-of-the-line waiting effects> Learn MoreJSJSJavaKotlinPythonRustGoJSJavaKotlinPythonRustGo
const eventEnricher = restate.object({
  name: "eventEnricher",
  handlers: {
    userEvent: async (ctx, event) => {
      // remember event, time box 100 ms to collect features
      // before emitting result
      ctx.set("user", event);
      ctx.serviceSendClient(eventEnricher, { delay: 100 }).emit();
    },
    featureEvent: async (ctx, featureEvent) => {
      // merge feature into event
      const userEvent = (await ctx.get("user")) ?? {};
      (userEvent.features ??= []).push(featureEvent);
      ctx.set("user", userEvent)
    },
    emit: async (ctx) => {
      emit(ctx.key, await ctx.get("user"));
      ctx.clearAll();
    }
  }
})


@VirtualObject
public class EventEnricher {
    static final StateKey USER = StateKey.of("user", of(User.class));
    @Handler
    public void userEvent(ObjectContext ctx, User event) {
        ctx.set(USER, event);
        // time box 100 ms to collect features before emitting result
        EventEnricherClient.fromContext(ctx, ctx.key())
            .send(ofMillis(100)).emit();
    }
    @Handler
    public void featureEvent(ObjectContext ctx, Feature event) {
        User user = ctx.get(USER).orElse(new User());
        user.addFeature(event);
        ctx.set(USER, user);
    }
    @Handler
    public void emit(ObjectContext ctx) {
        send(ctx.key(), ctx.get(USER));
        ctx.clearAll();
    }
}

Durable SignalsCreate workflows and event handlers that reliably handle external signals, events, human input.â€Use durable Promises/Futures to intuitively model signals and conditionsCreate signals from RPCs, webhooks, or Kafka eventsSignals and events are persisted by Restate, no need for a queue> Learn MoreJSJSJavaKotlinPythonRustGoJSJavaKotlinPythonRustGo
export default workflow({
  name: "verify",
  handlers: {
    run: async (ctx, { email }) => {
      const secret = ctx.run("generate secret", () =>
        crypto.randomUUID()
      );
      await ctx.run("send email", () => sendEmail({ email, secret }));

      const clickSecret = await ctx.promise("email.clicked");
      return clickSecret == secret;
    },
    click: (ctx, { secret }) => {
      ctx.promise("email.clicked").resolve(secret);
    },
  },
});





@Workflow
public class SecretVerifier {

    static final DurablePromiseKey EMAIL_CLICKED =
            DurablePromiseKey.of("email_clicked", JsonSerdes.STRING);

    @Workflow
    public boolean run(WorkflowContext ctx, Email email) {
        String secret = ctx.random().nextUUID().toString();
        ctx.run("send email",
            () -> sendEmailWithLink(email, secret));

        String clickSecret = ctx.promise(EMAIL_CLICKED).awaitable().await();
        return clickSecret.equals(secret);
    }

    @Handler
    public void click(SharedWorkflowContext ctx, String secret) {
        ctx.promiseHandle(EMAIL_CLICKED).resolve(secret);
    }
}

IdempotencyAdd idempotency to any RPC- or event handler.â€Every RPC- and event handler call accepts an idempotency keyUse idempotency keys to re-attach to an ongoing invocationCalls from within a durable execution context are automatically idempotent> Learn MoreJSJSJavaKotlinPythonRustGoJSJavaKotlinPythonRustGo
const rs = restate.connect({ url: process.env.RESTATE_URL });
app.get('/reserve/:product/:reservationId', async (req, res) => {
  const { product, reservationId } = req.params;
  const products = rs.serviceClient(ProductService);
  const reservation = await products.reserve(
    product,
    Opts.from({ idempotencyKey : reservationId })
  );
  res.json(reservation);
})


server.createContext("/reserve", httpExchange -> {
      ReservationRequest req = parseRequest(httpExchange.getRequestBody());
      // derive an idempotency key from the parameters
      var idempotencyOps = CallRequestOptions.DEFAULT
          .withIdempotency(req.getReservationId());
      // add idempotency opts to the request to let the service automatically
      // fuse repeated requests
      Reservation reservation = ProductServiceClient
          .fromIngress(RESTATE_RUNTIME_ENDPOINT)
          .reserve(req.getProduct(), idempotencyOps);
      sendResponse(httpExchange, reservation);
    });

SagasImplements robust sagas and compensation patterns: long-running transactions that undo previous actions when they need to abort and roll back.â€Reliably pick up after failures to trigger compensationsEnsure compensations happen even upon failures during the compensation phaseUse standard Exception/Error mechanisms and control flow rather than complex DSLs.> Learn MoreJSJSJavaKotlinPythonRustGoJSJavaKotlinPythonRustGo
async function reservation(ctx, products) {
  const reservations = [];
  try {
    for (const product of products) {
      const reservation = await ctx.run(`reserve ${product}`,
          () => reserve(product));
      reservations.push(reservation);
    }
  } catch (error) {
    if (error instanceof TerminalError) {
      for (const reservation of reservations) {
        await ctx.run("undo reserve", () => 
            cancelReservation(reservation));
      }
    }
    throw error;
  }
}


@Handler
public void reserveAllProducts(Context ctx, Product[] products) {
    final List reservations = new ArrayList<>();
    try {
        for (Product product : products) {
            Reservation res = ctx.run("Reserve " + product.getId(),
                RESERVE_SERDE, () -> reserve(product)
            );
            reservations.add(res);
        }
    } catch (TerminalException e) {
        reservations.forEach(res -> {
            ctx.run("Undo reservation", () -> cancelReservation(res));
        });
        throw e;
    }
}

State machinesCreate consistent and scalable State Machines without databases or transactionsâ€Run millions of State Machines that maintain state directly in the context of their handlersState changes commit atomically with function execution, for rock-solid consistencySingle-writer semantics for a dead simple concurrency model. A virtual queue per state machine for efficiency and scalability.State transition can be workflows with all the features from durable execution> Learn MoreJSJSJavaKotlinPythonRustGoJSJavaKotlinPythonRustGo
const paymentSvc = restate.object({
  name: "payments",
  handlers: {
    makePayment: async (ctx, payment) => {
      const paymentId = ctx.key;
      switch (await ctx.get("status")) {
        case "CANCELLED":
            return `${paymentId} was cancelled before`;
        case "SUCCESS":
            return `${paymentId} previously completed`;
      }
      wireFunds(payment);
      ctx.set("status", "SUCCESS");
      ctx.set("payment", payment);
    },
    cancelPayment: async (ctx) => {
      const status = await ctx.get("status");
      if (status === "SUCCESS") {
        const payment = await ctx.get("payment");
        refund(payment);
      }
      ctx.set("status", "CANCELLED");
    }
  }
});


@VirtualObject
public class PaymentStateMachine {
  @Handler
  public String makePayment(ObjectContext ctx, PaymentRequest payment) {
    String paymentId = ctx.key();
    switch (ctx.get(STATE_STATUS).orElse(NEW)) {
      case CANCELLED: return paymentId + " was cancelled before";
      case SUCCESS:   return paymentId + " was previously completed";
    }
    wireFunds(payment);
    ctx.set(STATE_STATUS, SUCCESS);
    ctx.set(STATE_PAYMENT_REQUEST, payment);
    return paymentId + " was successfully processed";
  }
  @Handler
  public void cancelPayment(ObjectContext ctx) {
    Status status = ctx.get(STATE_STATUS).orElse(NEW);
    if (status == SUCCESS) {
      PaymentRequest payment = ctx.get(STATE_PAYMENT_REQUEST).get();
      refund(payment);
    }
    ctx.set(STATE_STATUS, CANCELLED);
  }
}

A simple and powerful programming modelRestate provides distributed durable version of your everyday building blocks.> See how it worksDurable ExecutionFunctions/Services that handle retries, recovery, asynchrony, idempotency.Virtual ObjectsPersistent state directly in your objects with a simple concurrency model.Durable PromisesTransparent and fault-tolerant communication across services, processes, and time.Single binary, no dependencies, built in Rust.A system that runs locally and on-prem just as well as in the â€¨cloud. Restate server comes as a single binary. Simple to run, â€¨simple to operate.Fully self-contained, resource-efficient, resilient, thanks to â€¨Rustâ€™s magic.Stellar local dev-experienceWhatâ€™s better than a local dev server? Running the real system on your laptop or in your CI pipeline. No subtle quirks and differences between dev- and prod setups.Your Restate-powered code is just functions/services. Develop them with the tools you know and love.Low latencyworkflows-as-codeRestateâ€™s event-driven architecture offers very low latencies for durable invocations and workflow-as-code steps, supporting workflows on latency-critical and synchronous code paths.> See how it worksBuilt by the original creators of Apache FlinkRestate is built by the original creators of Apache Flink and lead engineers from Meta's data infrastructure.â€We built and operated some of the largest event processing setups on the planet.Works withTypeScript / JavaScriptJavaKotlinPythonGoRustRestate Cloud:Â The zero-infrastructure optionGet a fully serverless Restate experience, managed by the developers of the system.â€¨Sign in, generate keys, point your app, go!> Get StartedBaked-in powerful tools to operate applicationsBuilt-in OTel tracing, a powerful CLI, and aâ€¨SQL engine help you understand what is happening in your distributed application.Ready to get started?> SubscribeWant to get updates on releasesâ€¨and other news?Copyright Â© 2024 Restate. All rights reserved.T&CsPrivacyImprintContact







